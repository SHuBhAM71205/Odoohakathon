import { Binary } from './binary';
import type { Document } from './bson';
import { Code } from './code';
import {
  BSON_INT32_MAX,
  BSON_INT32_MIN,
  BSON_INT64_MAX,
  BSON_INT64_MIN,
  BSON_MAJOR_VERSION,
  BSON_VERSION_SYMBOL
} from './constants';
import { DBRef, isDBRefLike } from './db_ref';
import { Decimal128 } from './decimal128';
import { Double } from './double';
import { BSONError, BSONRuntimeError, BSONVersionError } from './error';
import { Int32 } from './int_32';
import { Long } from './long';
import { MaxKey } from './max_key';
import { MinKey } from './min_key';
import { ObjectId } from './objectid';
import { isDate, isRegExp, isMap } from './parser/utils';
import { BSONRegExp } from './regexp';
import { BSONSymbol } from './symbol';
import { Timestamp } from './timestamp';

  legacy?: boolean;
  /**
   * Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types
   * @defaultValue `false` */
  relaxed?: boolean;
  /**
   * Enable native bigint support
   * @defaultValue `false`
   */
  useBigInt64?: boolean;
};

    if (!options.relaxed) {
      return { $numberLong: BigInt.asIntN(64, value).toString() };
    }
    return Number(BigInt.asIntN(64, value));
    /* eslint-enable */
  }

  if (value instanceof RegExp || isRegExp(value)) {
    let flags = value.flags;
    if (flags === undefined) {
      const match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }

    const rx = new BSONRegExp(value.source, flags);
    return rx.toExtendedJSON(options);
  }

  if (value != null && typeof value === 'object') return serializeDocument(value, options);
  return value;
}

const BSON_TYPE_MAPPINGS = {
  Binary: (o: Binary) => new Binary(o.value(), o.sub_type),
  Code: (o: Code) => new Code(o.code, o.scope),
  DBRef: (o: DBRef) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields), // "namespace" for 1.x library backwards compat
  Decimal128: (o: Decimal128) => new Decimal128(o.bytes),
  Double: (o: Double) => new Double(o.value),
  Int32: (o: Int32) => new Int32(o.value),
  Long: (
    o: Long & {
      low_: number;
      high_: number;
      unsigned_: boolean | undefined;
    }
  ) =>
    Long.fromBits(
      // underscore variants for 1.x backwards compatibility
      o.low != null ? o.low : o.low_,
      o.low != null ? o.high : o.high_,
      o.low != null ? o.unsigned : o.unsigned_
    ),
  MaxKey: () => new MaxKey(),
  MinKey: () => new MinKey(),
  ObjectId: (o: ObjectId) => new ObjectId(o),
  BSONRegExp: (o: BSONRegExp) => new BSONRegExp(o.pattern, o.options),
  BSONSymbol: (o: BSONSymbol) => new BSONSymbol(o.value),
  Timestamp: (o: Timestamp) => Timestamp.fromBits(o.low, o.high)
} as const;

function serializeDocument(doc: any, options: EJSONSerializeOptions) {
  if (doc == null || typeof doc !== 'object') throw new BSONError('not an object instance');

  const bsontype: BSONType['_bsontype'] = doc._bsontype;
  if (typeof bsontype === 'undefined') {
    // It's a regular object. Recursively serialize its property values.
    const _doc: Document = {};
    for (const name of Object.keys(doc)) {
      options.seenObjects.push({ propertyName: name, obj: null });
      try {
        const value = serializeValue(doc[name], options);
        if (name === '__proto__') {
          Object.defineProperty(_doc, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (
    doc != null &&
    typeof doc === 'object' &&
    typeof doc._bsontype === 'string' &&
    doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION
  ) {
    throw new BSONVersionError();
  } else if (isBSONType(doc)) {
    // the "document" is really just a BSON type object
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let outDoc: any = doc;
    if (typeof outDoc.toExtendedJSON !== 'function') {
      // There's no EJSON serialization function on the object. It's probably an
      // object created by a previous version of this library (or another library)
      // that's duck-typing objects to look like they were generated by this library).
      // Copy the object into this library's version of that type.
      const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }

    // Two BSON types may have nested objects that may need to be serialized too
    if (bsontype === 'Code' && outDoc.scope) {
      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === 'DBRef' && outDoc.oid) {
      outDoc = new DBRef(
        serializeValue(outDoc.collection, options),
        serializeValue(outDoc.oid, options),
        serializeValue(outDoc.db, options),
        serializeValue(outDoc.fields, options)
      );
    }

    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);
  }
}

function parse(text: string, options?: EJSONOptions): any {
  const ejsonOptions = {
    useBigInt64: options?.useBigInt64 ?? false,
    relaxed: options?.relaxed ?? true,
    legacy: options?.legacy ?? false
  };
  return JSON.parse(text, (key, value) => {
    if (key.indexOf('\x00') !== -1) {
      throw new BSONError(
        `BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`
      );
    }
    return deserializeValue(value, ejsonOptions);
  });
}

function stringify(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  value: any,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSONOptions,
  space?: string | number,
  options?: EJSONOptions
): string {
  if (space != null && typeof space === 'object') {
    options = space;
    space = 0;
  }
  if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {
    options = replacer;
    replacer = undefined;
    space = 0;
  }
  const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
    seenObjects: [{ propertyName: '(root)', obj: null }]
  });

  const doc = serializeValue(value, serializeOptions);
  return JSON.stringify(doc, replacer as Parameters<JSON['stringify']>[1], space);
}

function EJSONserialize(value: any, options?: EJSONOptions): Document {
  options = options || {};
  return JSON.parse(stringify(value, options));
}

function EJSONdeserialize(ejson: Document, options?: EJSONOptions): any {
  options = options || {};
  return parse(JSON.stringify(ejson), options);
}

