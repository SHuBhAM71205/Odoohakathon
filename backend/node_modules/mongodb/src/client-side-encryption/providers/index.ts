import type { Binary } from '../../bson';
import { type AWSCredentialProvider } from '../../cmap/auth/aws_temporary_credentials';
import { loadAWSCredentials } from './aws';
import { loadAzureCredentials } from './azure';
import { loadGCPCredentials } from './gcp';

export type ClientEncryptionDataKeyProvider = keyof KMSProviders;

  accessKeyId: string;

  /**
   * The secret access key used for the AWS KMS provider
   */
  secretAccessKey: string;

  /**
   * An optional AWS session token that will be used as the
   * X-Amz-Security-Token header for AWS requests.
   */
  sessionToken?: string;
}

  key: Binary | Uint8Array | string;
}

  endpoint?: string;
}

      tenantId: string;

      /**
       * The client ID to authenticate a registered application
       */
      clientId: string;

      /**
       * The client secret to authenticate a registered application
       */
      clientSecret: string;

      /**
       * If present, a host with optional port. E.g. "example.com" or "example.com:443".
       * This is optional, and only needed if customer is using a non-commercial Azure instance
       * (e.g. a government or China account, which use different URLs).
       * Defaults to "login.microsoftonline.com"
       */
      identityPlatformEndpoint?: string | undefined;
    }
  | {
      /**
       * If present, an access token to authenticate with Azure.
       */
      accessToken: string;
    };

      email: string;

      /**
       * A PKCS#8 encrypted key. This can either be a base64 string or a binary representation
       */
      privateKey: string | Buffer;

      /**
       * If present, a host with optional port. E.g. "example.com" or "example.com:443".
       * Defaults to "oauth2.googleapis.com"
       */
      endpoint?: string | undefined;
    }
  | {
      /**
       * If present, an access token to authenticate with GCP.
       */
      accessToken: string;
    };

export interface CredentialProviders {
  /* A custom AWS credential provider */
  aws?: AWSCredentialProvider;
}

export interface KMSProviders {
  /**
   * Configuration options for using 'aws' as your KMS provider
   */
  aws?: AWSKMSProviderConfiguration | Record<string, never>;
  [key: `aws:${string}`]: AWSKMSProviderConfiguration;

  /**
   * Configuration options for using 'local' as your KMS provider
   */
  local?: LocalKMSProviderConfiguration;
  [key: `local:${string}`]: LocalKMSProviderConfiguration;

  /**
   * Configuration options for using 'kmip' as your KMS provider
   */
  kmip?: KMIPKMSProviderConfiguration;
  [key: `kmip:${string}`]: KMIPKMSProviderConfiguration;

  /**
   * Configuration options for using 'azure' as your KMS provider
   */
  azure?: AzureKMSProviderConfiguration | Record<string, never>;
  [key: `azure:${string}`]: AzureKMSProviderConfiguration;

  /**
   * Configuration options for using 'gcp' as your KMS provider
   */
  gcp?: GCPKMSProviderConfiguration | Record<string, never>;
  [key: `gcp:${string}`]: GCPKMSProviderConfiguration;
}

export function isEmptyCredentials(
  providerName: ClientEncryptionDataKeyProvider,
  kmsProviders: KMSProviders
): boolean {
  const provider = kmsProviders[providerName];
  if (provider == null) {
    return false;
  }
  return typeof provider === 'object' && Object.keys(provider).length === 0;
}

export async function refreshKMSCredentials(
  kmsProviders: KMSProviders,
  credentialProviders?: CredentialProviders
): Promise<KMSProviders> {
  let finalKMSProviders = kmsProviders;

  if (isEmptyCredentials('aws', kmsProviders)) {
    finalKMSProviders = await loadAWSCredentials(finalKMSProviders, credentialProviders?.aws);
  }

  if (isEmptyCredentials('gcp', kmsProviders)) {
    finalKMSProviders = await loadGCPCredentials(finalKMSProviders);
  }

  if (isEmptyCredentials('azure', kmsProviders)) {
    finalKMSProviders = await loadAzureCredentials(finalKMSProviders);
  }
  return finalKMSProviders;
}
