import { type Document } from '../../bson';
import type { Filter, OptionalId, UpdateFilter, WithoutId } from '../../mongo_types';
import type { CollationOptions, CommandOperationOptions } from '../../operations/command';
import type { Hint } from '../../operations/operation';
import { type Sort } from '../../sort';

  ordered?: boolean;
  /**
   * Allow driver to bypass schema validation.
   * @defaultValue `false` - documents will be validated by default
   **/
  bypassDocumentValidation?: boolean;
  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */
  let?: Document;
  /**
   * Whether detailed results for each successful operation should be included in the returned
   * BulkWriteResult.
   */
  verboseResults?: boolean;
}

  namespace: string;
}

  document: OptionalId<TSchema>;
}

  filter: Filter<TSchema>;
  /** Specifies a collation. */
  collation?: CollationOptions;
  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */
  hint?: Hint;
}

  filter: Filter<TSchema>;
  /** Specifies a collation. */
  collation?: CollationOptions;
  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */
  hint?: Hint;
}

  filter: Filter<TSchema>;
  /** The document with which to replace the matched document. */
  replacement: WithoutId<TSchema>;
  /** Specifies a collation. */
  collation?: CollationOptions;
  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */
  hint?: Hint;
  /** When true, creates a new document if no document matches the query. */
  upsert?: boolean;
  /** Specifies the sort order for the documents matched by the filter. */
  sort?: Sort;
}

  filter: Filter<TSchema>;
  /**
   * The modifications to apply. The value can be either:
   * UpdateFilter<Document> - A document that contains update operator expressions,
   * Document[] - an aggregation pipeline.
   */
  update: UpdateFilter<TSchema> | Document[];
  /** A set of filters specifying to which array elements an update should apply. */
  arrayFilters?: Document[];
  /** Specifies a collation. */
  collation?: CollationOptions;
  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */
  hint?: Hint;
  /** When true, creates a new document if no document matches the query. */
  upsert?: boolean;
  /** Specifies the sort order for the documents matched by the filter. */
  sort?: Sort;
}

  filter: Filter<TSchema>;
  /**
   * The modifications to apply. The value can be either:
   * UpdateFilter<Document> - A document that contains update operator expressions,
   * Document[] - an aggregation pipeline.
   */
  update: UpdateFilter<TSchema> | Document[];
  /** A set of filters specifying to which array elements an update should apply. */
  arrayFilters?: Document[];
  /** Specifies a collation. */
  collation?: CollationOptions;
  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */
  hint?: Hint;
  /** When true, creates a new document if no document matches the query. */
  upsert?: boolean;
}

export type AnyClientBulkWriteModel<TSchema extends Document> =
  | ClientInsertOneModel<TSchema>
  | ClientReplaceOneModel<TSchema>
  | ClientUpdateOneModel<TSchema>
  | ClientUpdateManyModel<TSchema>
  | ClientDeleteOneModel<TSchema>
  | ClientDeleteManyModel<TSchema>;

export type ClientBulkWriteModel<
  SchemaMap extends Record<string, Document> = Record<string, Document>
> = {
  [Namespace in keyof SchemaMap]: AnyClientBulkWriteModel<SchemaMap[Namespace]> & {
    namespace: Namespace;
  };
}[keyof SchemaMap];

  readonly acknowledged: boolean;
  /**
   * The total number of documents inserted across all insert operations.
   */
  readonly insertedCount: number;
  /**
   * The total number of documents upserted across all update operations.
   */
  readonly upsertedCount: number;
  /**
   * The total number of documents matched across all update operations.
   */
  readonly matchedCount: number;
  /**
   * The total number of documents modified across all update operations.
   */
  readonly modifiedCount: number;
  /**
   * The total number of documents deleted across all delete operations.
   */
  readonly deletedCount: number;
  /**
   * The results of each individual insert operation that was successfully performed.
   */
  readonly insertResults?: ReadonlyMap<number, ClientInsertOneResult>;
  /**
   * The results of each individual update operation that was successfully performed.
   */
  readonly updateResults?: ReadonlyMap<number, ClientUpdateResult>;
  /**
   * The results of each individual delete operation that was successfully performed.
   */
  readonly deleteResults?: ReadonlyMap<number, ClientDeleteResult>;
}

export interface ClientInsertOneResult {
  /**
   * The _id of the inserted document.
   */
  insertedId: any;
}

  matchedCount: number;

  /**
   * The number of documents that were modified.
   */
  modifiedCount: number;

  /**
   * The _id field of the upserted document if an upsert occurred.
   *
   * It MUST be possible to discern between a BSON Null upserted ID value and this field being
   * unset. If necessary, drivers MAY add a didUpsert boolean field to differentiate between
   * these two cases.
   */
  upsertedId?: any;

  /**
   * Determines if the upsert did include an _id, which includes the case of the _id being null.
   */
  didUpsert: boolean;
}

  deletedCount: number;
}
